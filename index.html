<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Zombs Offline — Upgrade Preview</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg:#07121a; --panel:rgba(255,255,255,0.03); --accent:#7ee; --good:#4fe08a; --warn:#ffd36b; --bad:#ff7b7b;
}
html,body{height:100%;margin:0;background:var(--bg);color:#eaf3f6;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
canvas{display:block;position:absolute;left:0;top:0}
#uiTop{position:absolute;left:12px;top:8px;right:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:none;z-index:20}
.panel{background:var(--panel);padding:8px 10px;border-radius:8px;font-size:13px;pointer-events:auto;display:flex;gap:12px;align-items:center}
#shop{position:absolute;left:12px;top:86px;background:rgba(0,0,0,0.28);padding:10px;border-radius:8px;width:340px;pointer-events:auto;z-index:20}
.shop-row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
.shop-btn{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
.shop-btn:hover{background:rgba(255,255,255,0.035)}
.shop-emoji{font-size:20px;width:36px;text-align:center}
.res-pill{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-weight:700}
#centerControls{position:absolute;left:364px;top:86px;background:rgba(0,0,0,0.18);padding:8px;border-radius:8px;pointer-events:auto;z-index:20}
#nightShade{position:absolute;inset:0;pointer-events:none;z-index:10}
.hudMsg{position:absolute;left:50%;transform:translateX(-50%);top:56px;background:rgba(0,0,0,0.36);padding:8px 14px;border-radius:8px;font-weight:700;pointer-events:none;z-index:30}
.player-hp{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.2);padding:8px;border-radius:8px;width:380px;pointer-events:none;z-index:20}
.hpBar{height:12px;border-radius:6px;background:rgba(255,255,255,0.06);overflow:hidden}
.hpFill{height:12px;background:linear-gradient(90deg,#ff6b6b,#ffcf6b);width:100%}
.small{font-size:12px;color:#9ab;margin-left:8px}
.centerNote{font-size:13px;color:#bcd;margin-top:6px}
.btn{background:#123; border-radius:6px; padding:6px 8px; color:#bfe; border:0; cursor:pointer}
.btn[disabled]{opacity:0.45; cursor:not-allowed}
.tooltip { position: absolute; background: rgba(0,0,0,0.8); padding:6px 8px; border-radius:6px; font-size:12px; color:#fff; pointer-events:none; z-index:40; display:none; }
.upgrade-preview { font-family: monospace; font-size:12px; color:#cfe; }
.upgrade-preview .old { color:#aab; }
.upgrade-preview .new { color:#ffd36b; font-weight:700; margin-left:8px; }
.upgrade-preview .delta { color:#9f9; margin-left:6px; }
</style>
</head>
<body>
  <div id="uiTop">
    <div id="leftPanel" class="panel">
      <div><strong>Wave:</strong> <span id="wave">0</span></div>
      <div><strong>Lives:</strong> <span id="lives">10</span></div>
      <div><strong>Time:</strong> <span id="dayNight">Day</span></div>
      <div class="small" id="dayTimer">(—)</div>
    </div>

    <div id="rightPanel" class="panel">
      <div class="res-pill">🪵 <span id="goldWood">0</span></div>
      <div class="res-pill">🪨 <span id="goldStone">0</span></div>
      <div class="res-pill">💰 <span id="goldCount">0</span></div>
    </div>
  </div>

  <div id="hudMsg" class="hudMsg" style="display:none"></div>

  <div id="shop" aria-label="Build menu">
    <div style="font-weight:800;margin-bottom:8px">BUILD</div>

    <div class="shop-row">
      <div class="shop-btn" data-build="stash" title="Free — required to start waves">
        <div class="shop-emoji">🏆</div>
        <div><strong>Gold Stash</strong><div class="small">Free — required</div></div>
        <div style="margin-left:auto;font-weight:700">Free</div>
      </div>
    </div>

    <div class="shop-row">
      <div class="shop-btn" data-build="mine" title="Mine cost: 20 wood, 10 stone (max 8)">
        <div class="shop-emoji">⛏️</div>
        <div><strong>Gold Mine</strong><div class="small">Produces gold over time (place ASAP)</div></div>
        <div style="margin-left:auto;font-weight:700">20🪵 10🪨</div>
      </div>
    </div>

    <div style="height:8px"></div>
    <div style="font-weight:700;margin-top:6px">TOWERS</div>

    <div class="shop-row">
      <div class="shop-btn" data-build="fire" title="Fire Tower: 30 wood, 15 stone">
        <div class="shop-emoji">🔥</div>
        <div><strong>Fire Tower</strong><div class="small">Average damage + burn</div></div>
        <div style="margin-left:auto;font-weight:700">30🪵 15🪨</div>
      </div>
    </div>

    <div class="shop-row">
      <div class="shop-btn" data-build="cold" title="Cold Tower: 25 wood, 20 stone">
        <div class="shop-emoji">❄️</div>
        <div><strong>Cold Tower</strong><div class="small">Strong slow, low dmg</div></div>
        <div style="margin-left:auto;font-weight:700">25🪵 20🪨</div>
      </div>
    </div>

    <div class="shop-row">
      <div class="shop-btn" data-build="poison" title="Poison Tower: 40 wood, 25 stone">
        <div class="shop-emoji">☠️</div>
        <div><strong>Poison Tower</strong><div class="small">Low hit, poison DOT</div></div>
        <div style="margin-left:auto;font-weight:700">40🪵 25🪨</div>
      </div>
    </div>

    <div style="margin-top:8px;font-weight:700">TOOLS</div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button class="btn" id="forceNightBtn">Force Night</button>
      <button class="btn" id="wipeBaseBtn">Wipe Base</button>
      <button class="btn" id="sellBtn">Sell Selected</button>
    </div>

    <div class="centerNote" style="margin-top:8px">Click an item, then click the map to place. Double-click map quick-places. Keys: 1-5 select.</div>
  </div>

  <div id="centerControls" class="panel" style="left:364px;top:86px;position:absolute">
    <div style="font-weight:700">Controls</div>
    <div style="display:flex;gap:8px;align-items:center">
      <div class="small">WASD move • Left-click / Space = Use tool</div>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
      <button class="btn" id="toolHand">Hand</button>
      <button class="btn" id="toolAxe">Axe</button>
    </div>
  </div>

  <div id="nightShade"></div>
  <div class="player-hp"><div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:6px"><div>Player HP</div><div id="hpText">100/100</div></div><div class="hpBar"><div id="hpFill" class="hpFill" style="width:100%"></div></div></div>

  <div id="tooltip" class="tooltip"></div>

  <!-- Action panel shows when you click a building -->
  <div id="actionPanel" class="panel" style="display:none; position:absolute; z-index:60; left:20px; top:120px; flex-direction:column; gap:8px;">
    <div id="actionTitle" style="font-weight:800">Selected</div>
    <div id="actionInfo" class="small">--</div>
    <div id="upgradePreview" class="upgrade-preview" style="display:block"></div>
    <div style="display:flex;gap:8px">
      <button class="btn" id="actionSellBtn">Sell</button>
      <button class="btn" id="actionUpgradeBtn">Upgrade</button>
      <button class="btn" id="actionCloseBtn">Close</button>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

<script>
(() => {
  // --- Canvas & sizing ---
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resize(){
    const w = Math.max(640, window.innerWidth), h = Math.max(480, window.innerHeight);
    canvas.width = Math.floor(w);
    canvas.height = Math.floor(h);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resize);
  resize();

  // --- DOM refs (grab before wiring) ---
  const HUD_wave = document.getElementById('wave');
  const HUD_lives = document.getElementById('lives');
  const HUD_gold = document.getElementById('goldCount');
  const HUD_wood = document.getElementById('goldWood');
  const HUD_stone = document.getElementById('goldStone');
  const HUD_hpText = document.getElementById('hpText');
  const HUD_hpFill = document.getElementById('hpFill');
  const HUD_dayNight = document.getElementById('dayNight');
  const HUD_dayTimer = document.getElementById('dayTimer');
  const HUD_msg = document.getElementById('hudMsg');
  const tooltip = document.getElementById('tooltip');
  const nightShade = document.getElementById('nightShade');

  const forceBtn = document.getElementById('forceNightBtn');
  const wipeBtn  = document.getElementById('wipeBaseBtn');
  const sellBtn  = document.getElementById('sellBtn');

  const toolHandBtn = document.getElementById('toolHand');
  const toolAxeBtn  = document.getElementById('toolAxe');

  const actionPanel  = document.getElementById('actionPanel');
  const actionTitle  = document.getElementById('actionTitle');
  const actionInfo   = document.getElementById('actionInfo');
  const upgradePreview = document.getElementById('upgradePreview');
  const actionSellBtn = document.getElementById('actionSellBtn');
  const actionUpgradeBtn = document.getElementById('actionUpgradeBtn');
  const actionCloseBtn = document.getElementById('actionCloseBtn');

  // --- Input ---
  const keys = {}, mouse = { x:0, y:0, down:false };
  document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
  canvas.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (e.clientY - r.top)  * (canvas.height / r.height);
    tooltipFollow();
  });
  canvas.addEventListener('mousedown', e => { if(e.button===0) mouse.down = true; });
  canvas.addEventListener('mouseup', e => { if(e.button===0) mouse.down = false; });
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // --- Utilities ---
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  function roundRect(x,y,w,h,r,fill){
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
    if(fill) ctx.fill(); else ctx.stroke();
  }

  // --- Persistence ---
  const SAVE_KEY = 'zombs_offline_wired_v1';
  function savePersist(state){ try { localStorage.setItem(SAVE_KEY, JSON.stringify({ gold:Math.floor(state.gold), wood:Math.floor(state.wood), stone:Math.floor(state.stone) })); } catch(e){} }
  function loadPersist(state){ try { const raw = localStorage.getItem(SAVE_KEY); if(raw){ const o = JSON.parse(raw); if(typeof o.gold==='number') state.gold = o.gold; if(typeof o.wood==='number') state.wood = o.wood; if(typeof o.stone==='number') state.stone = o.stone; } } catch(e){} }

  // --- HUD helpers ---
  let msgTimer = 0;
  function showHUDMessage(text, ms=2000){ HUD_msg.style.display = 'block'; HUD_msg.textContent = text; msgTimer = ms; }
  function updateHUDMessageTimer(dt){ if(msgTimer > 0){ msgTimer -= dt*1000; if(msgTimer <= 0) HUD_msg.style.display = 'none'; } }
  function showTooltip(text){ tooltip.style.display = 'block'; tooltip.textContent = text; tooltipFollow(); }
  function hideTooltip(){ tooltip.style.display = 'none'; }
  function tooltipFollow(){
    if(tooltip.style.display === 'none') return;
    const x = Math.max(10, mouse.x + 12);
    const y = Math.max(10, mouse.y + 12);
    tooltip.style.left = (x) + 'px';
    tooltip.style.top = (y) + 'px';
  }

  // Bind shop buttons
  function bindBuildButtons(selectBuild){
    const buildButtons = document.querySelectorAll('.shop-btn');
    buildButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const kind = btn.dataset.build;
        if(kind) selectBuild(kind);
      });
      btn.addEventListener('mouseenter', (e) => {
        const t = btn.getAttribute('title') || btn.dataset.build || '';
        showTooltip(t || ' ');
      });
      btn.addEventListener('mouseleave', hideTooltip);
    });
  }

  // --- Entities ---
  class ResourceNode {
    constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.size=(type==='tree'?20:16); this.shake=0; }
    harvest(state){
      const amt = 1;
      if(this.type==='tree') state.wood += amt; else state.stone += amt;
      this.shake = 0.8; savePersist(state); updateHUD();
      showHUDMessage(`+${amt} ${this.type==='tree'?'wood':'stone'}`, 900);
    }
    update(dt){ if(this.shake>0) this.shake = Math.max(0, this.shake - dt); }
    draw(offX,offY){
      let sx = this.x - offX, sy = this.y - offY;
      if(this.shake>0){ sx += Math.sin(this.shake*30)*4; sy += Math.cos(this.shake*20)*2; }
      if(sx < -40 || sx > canvas.width+40 || sy < -40 || sy > canvas.height+40) return;
      ctx.save(); ctx.translate(sx, sy);
      if(this.type==='tree'){
        ctx.fillStyle='#6b3f1f'; ctx.fillRect(-6,6,12,12);
        ctx.beginPath(); ctx.fillStyle='#2aa04a'; ctx.arc(0,-6,18,0,Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle='#9ba0a5'; ctx.beginPath(); ctx.moveTo(-12,6); ctx.lineTo(-8,-8); ctx.lineTo(6,-10); ctx.lineTo(12,6); ctx.closePath(); ctx.fill();
        ctx.fillStyle='#7e8488'; ctx.fillRect(-6,4,12,8);
      }
      ctx.restore();
    }
  }

  class Player {
    constructor(x,y){ this.x=x; this.y=y; this.size=14; this.speed=200; this.hp=100; this.swing=0; }
    update(dt){
      let dx=0,dy=0;
      if(keys['w']) dy-=1; if(keys['s']) dy+=1; if(keys['a']) dx-=1; if(keys['d']) dx+=1;
      if(dx||dy){ const L=Math.hypot(dx,dy)||1; dx/=L; dy/=L; this.x += dx*this.speed*dt; this.y += dy*this.speed*dt; }
      // collisions
      const blockers = [...state.resourceNodes, ...state.towers, ...state.mines, ...(state.stash? [state.stash] : [])];
      for(const b of blockers){
        const bx=b.x, by=b.y, br=(b.size||18)+6;
        const d = Math.hypot(this.x - bx, this.y - by);
        if(d < br + this.size){
          const overlap = br + this.size - d;
          if(d>0){ this.x += (this.x-bx)/d * overlap; this.y += (this.y-by)/d * overlap; } else { this.x += overlap; this.y += overlap; }
        }
      }
      this.x = clamp(this.x, this.size+6, MAP_W - (this.size+6));
      this.y = clamp(this.y, this.size+6, MAP_H - (this.size+6));
      if(this.swing>0) this.swing = Math.max(0, this.swing - dt);
    }
    draw(offX,offY){
      const sx = this.x - offX, sy = this.y - offY; if(sx < -50 || sx > canvas.width+50 || sy < -50 || sy > canvas.height+50) return;
      ctx.save(); ctx.translate(sx, sy); ctx.fillStyle='#dfe'; roundRect(-12,-10,24,20,5,true);
      if(this.swing > 0){ ctx.save(); const a = (1 - this.swing/0.22) * Math.PI*0.75 - Math.PI*0.25; ctx.rotate(a); ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.moveTo(12,0); ctx.arc(0,0,34, a-0.4, a+0.4); ctx.closePath(); ctx.fill(); ctx.restore(); }
      ctx.restore();
    }
  }

  class Tower {
    constructor(x,y,kind){ this.x=x; this.y=y; this.kind=kind; this.level=1; this.cool=0; this.size=14;
      if(kind==='fire'){ this.range=170; this.rate=0.9; this.dmg=28; this.bsp=420; this.burn=6; }
      if(kind==='cold'){ this.range=150; this.rate=1.1; this.dmg=12; this.bsp=380; this.slow=0.45; }
      if(kind==='poison'){ this.range=160; this.rate=1.0; this.dmg=10; this.bsp=360; this.poison=4; }
    }
    update(dt){
      this.cool -= dt;
      if(this.cool <= 0){
        let nearest=null, nd=9999;
        for(const e of state.enemies){ const d = Math.hypot(e.x - this.x, e.y - this.y); if(d < nd && d <= this.range){ nd=d; nearest=e; } }
        if(nearest){
          const evx = nearest.vx||0, evy = nearest.vy||0;
          let relx = nearest.x - this.x, rely = nearest.y - this.y;
          let t = Math.hypot(relx,rely)/(this.bsp||420) || 0.5;
          t = Math.max(0, Math.hypot(relx + evx*t, rely + evy*t)/(this.bsp||420));
          const aimX = nearest.x + evx*t, aimY = nearest.y + evy*t;
          const ang = Math.atan2(aimY - this.y, aimX - this.x);
          const speed = this.bsp;
          state.bullets.push({ x:this.x + Math.cos(ang)*14, y:this.y + Math.sin(ang)*14, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:2, dmg:this.dmg, aoe:(this.kind==='fire'?36:0), towerKind:this.kind });
          this.cool = this.rate / (1 + 0.1*(this.level-1));
        }
      }
    }
    draw(offX,offY,selected){
      const sx = this.x - offX, sy = this.y - offY; if(sx < -50 || sx > canvas.width+50 || sy < -50 || sy > canvas.height+50) return;
      ctx.save(); ctx.translate(sx, sy); if(this.kind==='fire') ctx.fillStyle='#ff9a6b'; else if(this.kind==='cold') ctx.fillStyle='#9ad8ff'; else ctx.fillStyle='#9ef08a';
      roundRect(-12,-12,24,24,6,true);
      if(selected){ ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=3; ctx.strokeRect(-16,-16,32,32); ctx.lineWidth=1; ctx.strokeStyle='#000'; }
      ctx.restore();
    }
  }

  class Mine {
    constructor(x,y){ this.x=x; this.y=y; this.size=16; this.goldPerSec=1; this.accum=0; }
    update(dt){ this.accum += this.goldPerSec * dt; }
    draw(offX,offY){ const sx = this.x - offX, sy = this.y - offY; if(sx < -50 || sx > canvas.width+50 || sy < -50 || sy > canvas.height+50) return; ctx.save(); ctx.translate(sx, sy); ctx.fillStyle='#ffd67a'; roundRect(-14,-10,28,20,6,true); ctx.restore(); }
  }

  class Enemy {
    constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.size=12;
      if(type==='walker'){ this.maxSpeed=68; this.hp=56; } else if(type==='runner'){ this.maxSpeed=150; this.hp=38; } else { this.maxSpeed=36; this.hp=220; }
      this.vx=0; this.vy=0; this.accel=380; this.effects={burn:0,slow:0,poison:0}; this.slowFactor=0;
    }
    applyEffect(kind,value,dur){
      if(kind==='burn') this.effects.burn = Math.max(this.effects.burn, dur);
      if(kind==='slow'){ this.effects.slow = Math.max(this.effects.slow, dur); this.slowFactor = Math.min(0.9, (this.slowFactor||0) + value); }
      if(kind==='poison') this.effects.poison = Math.max(this.effects.poison, dur);
    }
    update(dt){
      if(this.effects.burn > 0){ this.hp -= 4*dt; this.effects.burn = Math.max(0, this.effects.burn - dt); }
      if(this.effects.poison > 0){ this.hp -= 1.2*dt; this.effects.poison = Math.max(0, this.effects.poison - dt); }

      let target = {x:MAP_W/2, y:MAP_H/2};
      let bd = Math.hypot(target.x - this.x, target.y - this.y);
      if(state.stash){
        bd = Math.hypot(state.stash.x - this.x, state.stash.y - this.y);
        target = { x: state.stash.x, y: state.stash.y };
      }
      const obstacles = [...state.mines, ...state.towers];
      if(state.player) obstacles.push(state.player);
      for(const o of obstacles){
        if(!o) continue;
        const d = Math.hypot(o.x - this.x, o.y - this.y);
        if(d < bd){ bd=d; target={x:o.x,y:o.y}; }
      }

      const dx = target.x - this.x, dy = target.y - this.y, len = Math.hypot(dx,dy)||1;
      let speed = this.maxSpeed;
      if(this.effects.slow && this.effects.slow > 0){ speed *= (1 - (this.slowFactor || 0)); this.effects.slow = Math.max(0, this.effects.slow - dt); }
      const desiredVX = (dx/len) * speed, desiredVY = (dy/len) * speed;
      this.vx += clamp(desiredVX - this.vx, -this.accel*dt, this.accel*dt);
      this.vy += clamp(desiredVY - this.vy, -this.accel*dt, this.accel*dt);
      this.x += this.vx * dt; this.y += this.vy * dt;

      for(const o of state.enemies){ if(o===this) continue; const dd = Math.hypot(this.x-o.x,this.y-o.y); if(dd>0 && dd < this.size+o.size+6){ const push=(this.size+o.size+6 - dd)*0.18; this.x += (this.x-o.x)/dd * push; this.y += (this.y-o.y)/dd * push; } }

      if(Math.hypot(this.x - MAP_W/2, this.y - MAP_H/2) < 28){
        if(state.stash){ state.stash.hp -= 8 * dt; if(state.stash.hp <= 0){ state.stash.hp = 0; } }
        state.lives = Math.max(0, state.lives - 1);
        this.hp = 0;
        if(state.player){ state.player.hp -= 20; }
        updateHUD();
        if(state.player && state.player.hp <= 0){
          state.player.hp = 100; state.player.x = MAP_W/2 + 48; state.player.y = MAP_H/2 + 8; showHUDMessage('You died — respawned',1500);
        }
      }
      const obstacles2 = [...state.towers, ...state.mines];
      if(state.player) obstacles2.push(state.player);
      for(const o of obstacles2){
        if(!o || !o.size) continue;
        const d = Math.hypot(o.x - this.x, o.y - this.y);
        if(d < this.size + o.size){ if(o.hp !== undefined){ o.hp -= 10 * dt; } }
      }
    }
    draw(offX,offY){ const sx = this.x - offX, sy = this.y - offY; if(sx < -60 || sx > canvas.width+60 || sy < -60 || sy > canvas.height+60) return; ctx.save(); ctx.translate(sx, sy); ctx.fillStyle = (this.type==='runner'? '#ff8c6b': this.type==='tank'? '#aa6' : '#9a9'); ctx.beginPath(); ctx.arc(0,0,this.size,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  }

  // --- Constants & state ---
  const MAP_W = 2000, MAP_H = 1400;
  const COSTS = { mine:{wood:20,stone:10}, fire:{wood:30,stone:15}, cold:{wood:25,stone:20}, poison:{wood:40,stone:25} };

  const state = {
    player:null, cam:{x:0,y:0},
    resourceNodes:[], towers:[], mines:[], stash:null,
    enemies:[], bullets:[],
    gold:0, wood:120, stone:80,
    timeOfDay:0, cycleDay:60, cycleNight:40, inNight:false, wave:0, lives:10,
    selectedBuild:null, selectedObject:null,
    handCooldown:0, handMax:0.5, handRange:42,
    selectedTool: 'hand'
  };

  // --- Core functions ---
  function updateBullets(dt){
    for(let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
      if(b.life <= 0 || b.x < -200 || b.y < -200 || b.x > MAP_W + 200 || b.y > MAP_H + 200){ state.bullets.splice(i,1); continue; }
      for(let j=state.enemies.length-1;j>=0;j--){
        const e = state.enemies[j];
        const d = Math.hypot(b.x - e.x, b.y - e.y);
        if(d < e.size + 4){
          e.hp -= b.dmg;
          if(b.towerKind === 'fire'){ e.applyEffect('burn',6,4); }
          else if(b.towerKind === 'cold'){ e.applyEffect('slow',0.45,2.8); }
          else if(b.towerKind === 'poison'){ e.applyEffect('poison',3,6); }
          if(b.aoe){
            for(const o of state.enemies){ const d2 = Math.hypot(b.x - o.x, b.y - o.y); if(d2 < b.aoe) o.hp -= Math.round(b.dmg * 0.6); }
          }
          state.bullets.splice(i,1);
          break;
        }
      }
    }
  }

  function spawnWave(count){
    for(let i=0;i<count;i++){
      const side = Math.floor(Math.random()*4); let x=0,y=0;
      if(side===0){ x = Math.random()*MAP_W; y = -40; } else if(side===1){ x = Math.random()*MAP_W; y = MAP_H + 40; } else if(side===2){ x = -40; y = Math.random()*MAP_H; } else { x = MAP_W + 40; y = Math.random()*MAP_H; }
      const r = Math.random(); let type = 'walker';
      if(r < Math.min(0.06 + state.wave*0.01, 0.22)) type = 'tank';
      else if(r > 0.9 && state.wave > 3) type = 'runner';
      state.enemies.push(new Enemy(x,y,type));
    }
  }

  function updateDayNight(dt){
    state.timeOfDay += dt;
    const cycle = state.cycleDay + state.cycleNight;
    if(state.timeOfDay >= cycle) state.timeOfDay -= cycle;
    state.inNight = state.timeOfDay >= state.cycleDay;
    if(state.inNight){ HUD_dayNight.textContent = 'Night'; HUD_dayTimer.textContent = `Night ${Math.ceil(state.cycleDay+state.cycleNight - state.timeOfDay)}s`; }
    else { HUD_dayNight.textContent = 'Day'; HUD_dayTimer.textContent = `Day ${Math.ceil(state.cycleDay - state.timeOfDay)}s`; }
    if(state.inNight && !state._nightStarted && state.stash){
      state._nightStarted = true; state.wave++; HUD_wave.textContent = state.wave;
      const count = 5 + Math.floor(state.wave * 1.8);
      spawnWave(count); showHUDMessage(`Night ${state.wave} — ${count} zombies incoming`, 3000);
    } else if(!state.inNight) state._nightStarted = false;
    if(state.inNight) nightShade.style.background = 'linear-gradient(rgba(0,0,0,0.18), rgba(0,0,0,0.45))'; else nightShade.style.background = 'transparent';
  }

  function playerHandAction(){
    if(state.handCooldown > 0){ showHUDMessage('Tool cooling down', 900); return; }
    state.handCooldown = state.handMax; state.player.swing = 0.22;
    // harvest nodes near player — only if tool is axe
    if(state.selectedTool === 'axe'){
      for(const r of state.resourceNodes){
        const d = Math.hypot(r.x - state.player.x, r.y - state.player.y);
        if(d < state.handRange + r.size){ r.harvest(state); updateHUD(); return; }
      }
    }
    // mines withdraw
    for(const m of state.mines){
      const d = Math.hypot(m.x - state.player.x, m.y - state.player.y);
      if(d < state.handRange + m.size){
        const amt = Math.floor(m.accum);
        if(amt > 0){ state.gold += amt; m.accum = 0; savePersist(state); updateHUD(); showHUDMessage(`+${amt} gold`); return; }
      }
    }
    // stash deposit
    if(state.stash){
      const d = Math.hypot(state.stash.x - state.player.x, state.stash.y - state.player.y);
      if(d < state.handRange + (state.stash.size||18)){
        const dep = Math.floor(state.gold * 0.5);
        if(dep > 0){ state.gold -= dep; state.stash.stored = (state.stash.stored||0) + dep; savePersist(state); updateHUD(); showHUDMessage(`Deposited ${dep} gold`); return; }
      }
    }
    // hit enemies (works with both tools)
    let hit=null, hd=9999;
    for(const e of state.enemies){
      const d = Math.hypot(e.x - state.player.x, e.y - state.player.y);
      if(d < state.handRange + e.size && d < hd){ hd=d; hit=e; }
    }
    if(hit){ const dmg = 12; hit.hp -= dmg; const dx=(hit.x - state.player.x)||1, dy=(hit.y - state.player.y)||0, ln=Math.hypot(dx,dy)||1; hit.x += (dx/ln)*8; hit.y += (dy/ln)*8; showHUDMessage(`Hit enemy -${dmg}`); return; }
    showHUDMessage('Nothing to hit or harvest', 900);
  }

  function snapToGrid(wx,wy){ const grid = 20; return { x: Math.round(wx / grid) * grid, y: Math.round(wy / grid) * grid }; }

  function canPlace(x,y, radius=28){
    if(Math.hypot(x - MAP_W/2, y - MAP_H/2) < 80) return false;
    for(const r of state.resourceNodes) if(Math.hypot(r.x - x, r.y - y) < (r.size + radius)) return false;
    for(const t of state.towers) if(Math.hypot(t.x - x, t.y - y) < (t.size + radius)) return false;
    for(const m of state.mines) if(Math.hypot(m.x - x, m.y - y) < (m.size + radius)) return false;
    if(state.stash && Math.hypot(state.stash.x - x, state.stash.y - y) < (22 + radius)) return false;
    if(x < 40 || y < 40 || x > MAP_W - 40 || y > MAP_H - 40) return false;
    return true;
  }

  function placeSelectedBuild(wx,wy){
    const sb = state.selectedBuild;
    if(!sb){ showHUDMessage('No building selected', 900); return; }
    const snapped = snapToGrid(wx,wy); wx = snapped.x; wy = snapped.y;
    if(sb === 'stash'){
      if(state.stash){ showHUDMessage('Stash already exists', 1200); return; }
      if(!canPlace(wx,wy,36)){ showHUDMessage('Cannot place stash there', 1200); return; }
      state.stash = { x:wx, y:wy, size:20, hp:450, stored:0 };
      state.selectedBuild = null; savePersist(state); showHUDMessage('Gold Stash placed', 1200); return;
    }
    if(!state.stash){ showHUDMessage('Build a Gold Stash first', 1200); return; }
    if(sb === 'mine'){
      if(state.mines.length >= 8){ showHUDMessage('Max 8 mines', 1200); return; }
      const cost = COSTS.mine;
      if(state.wood < cost.wood || state.stone < cost.stone){ showHUDMessage('Not enough resources', 1200); return; }
      if(!canPlace(wx,wy,28)){ showHUDMessage('Cannot place mine there', 1200); return; }
      state.wood -= cost.wood; state.stone -= cost.stone;
      state.mines.push(new Mine(wx,wy)); state.selectedBuild=null; savePersist(state); updateHUD(); showHUDMessage('Mine placed', 1200); return;
    }
    if(sb === 'fire' || sb === 'cold' || sb === 'poison'){
      const cost = COSTS[sb];
      if(state.wood < cost.wood || state.stone < cost.stone){ showHUDMessage('Not enough resources', 1200); return; }
      if(!canPlace(wx,wy,28)){ showHUDMessage('Cannot place tower there', 1200); return; }
      state.wood -= cost.wood; state.stone -= cost.stone;
      state.towers.push(new Tower(wx,wy,sb)); state.selectedBuild=null; savePersist(state); updateHUD(); showHUDMessage(`${sb.charAt(0).toUpperCase()+sb.slice(1)} Tower placed`, 1200); return;
    }
  }

  // --- Upgrade preview helpers ---
  function computeUpgradeCostForTower(t){
    const base = { fire:{w:30,s:15}, cold:{w:25,s:20}, poison:{w:40,s:25} }[t.kind] || {w:30,s:15};
    const scaleW = 0.7, scaleS = 0.6;
    const costW = Math.ceil(base.w * (1 + (t.level||1) * scaleW));
    const costS = Math.ceil(base.s * (1 + (t.level||1) * scaleS));
    return { wood: costW, stone: costS };
  }

  function simulateUpgradeStats(t){
    const newLevel = (t.level || 1) + 1;
    const newDmg = Math.round((t.dmg || 10) * 1.25);
    const newRange = Math.round((t.range || 150) * 1.10);
    const newRate = Math.max(0.18, (t.rate || 1.0) * 0.92);
    return { level: newLevel, dmg: newDmg, range: newRange, rate: Number(newRate.toFixed(2)) };
  }

  function formatStatLine(label, oldVal, newVal){
    // returns HTML string for upgradePreview element
    const delta = (typeof oldVal === 'number') ? (newVal - oldVal) : '';
    const deltaText = (delta === '' ? '' : ` <span class="delta">(${delta>0?'+':''}${delta})</span>`);
    return `<div><span class="old">${label}: ${oldVal}</span><span class="new"> → ${newVal}</span>${deltaText}</div>`;
  }

  // --- Action panel update (with per-tower preview) ---
  function showActionPanel(title, obj){
    actionTitle.textContent = title;
    let lines = [];
    upgradePreview.innerHTML = '';
    if(title === 'Gold Stash'){
      lines.push(`HP: ${Math.round(obj.hp||0)}`);
      lines.push(`Stored: ${obj.stored||0} gold`);
      actionUpgradeBtn.style.display = 'none';
      upgradePreview.style.display = 'none';
    }
    else if(title === 'Mine'){
      lines.push(`Accum: ${Math.floor(obj.accum||0)} gold`);
      actionUpgradeBtn.style.display = 'none';
      upgradePreview.style.display = 'none';
    }
    else if(title === 'Tower'){
      lines.push(`Kind: ${obj.kind}  Level: ${obj.level||1}`);
      lines.push(`Dmg: ${Math.round(obj.dmg||0)}  Rate: ${Number((obj.rate||1).toFixed(2))}s  Range: ${Math.round(obj.range||0)}`);
      const upCost = computeUpgradeCostForTower(obj);
      lines.push(`Upgrade cost → ${upCost.wood}🪵 ${upCost.stone}🪨`);
      actionUpgradeBtn.style.display = 'inline-block';
      upgradePreview.style.display = 'block';
      // compute preview lines
      const sim = simulateUpgradeStats(obj);
      upgradePreview.innerHTML =
        formatStatLine('Damage', Math.round(obj.dmg||0), sim.dmg) +
        formatStatLine('Rate (s)', Number((obj.rate||1).toFixed(2)), sim.rate) +
        formatStatLine('Range', Math.round(obj.range||0), sim.range);
      // enable/disable upgrade button depending on resources
      actionUpgradeBtn.disabled = !(state.wood >= upCost.wood && state.stone >= upCost.stone);
      actionUpgradeBtn._cost = upCost; // stash cost for quick access
    }
    actionInfo.textContent = lines.join(' • ');
    const sx = Math.round(obj.x - state.cam.x);
    const sy = Math.round(obj.y - state.cam.y);
    const panelX = clamp(sx + 16, 8, canvas.width - 260);
    const panelY = clamp(sy - 10, 8, canvas.height - 140);
    actionPanel.style.left = panelX + 'px';
    actionPanel.style.top  = panelY + 'px';
    actionPanel.style.display = 'flex';
  }

  function upgradeSelected(){
    if(!state.selectedObject || state.selectedObject.type !== 'tower'){
      showHUDMessage('No tower selected', 900); return;
    }
    const t = state.selectedObject.obj;
    const upCost = computeUpgradeCostForTower(t);
    if(state.wood < upCost.wood || state.stone < upCost.stone){
      showHUDMessage('Not enough resources', 900); return;
    }
    state.wood -= upCost.wood;
    state.stone -= upCost.stone;
    t.level = (t.level || 1) + 1;
    t.dmg = Math.round((t.dmg || 10) * 1.25);
    t.range = Math.round((t.range || 150) * 1.10);
    t.rate = Math.max(0.18, (t.rate || 1.0) * 0.92);
    savePersist(state); updateHUD(); showHUDMessage(`${t.kind.charAt(0).toUpperCase()+t.kind.slice(1)} Tower upgraded to L${t.level}`, 1400);
    showActionPanel('Tower', t);
  }

  // --- Clicking/picking & sell ---
  function pickAt(wx,wy){
    state.selectedObject = null;
    for(const t of state.towers) if(Math.hypot(t.x - wx, t.y - wy) < 22){ state.selectedObject = {type:'tower', obj:t}; showHUDMessage(`Selected tower (${t.kind})`,1100); showActionPanel('Tower', t); return; }
    for(const m of state.mines) if(Math.hypot(m.x - wx, m.y - wy) < 22){ state.selectedObject = {type:'mine', obj:m}; showHUDMessage('Selected mine',1100); showActionPanel('Mine', m); return; }
    if(state.stash && Math.hypot(state.stash.x - wx, state.stash.y - wy) < 28){ state.selectedObject = {type:'stash', obj: state.stash}; showHUDMessage('Selected stash',1100); showActionPanel('Gold Stash', state.stash); return; }
    state.selectedObject = null;
    actionPanel.style.display = 'none';
    showHUDMessage('No building selected', 1000);
  }

  function sellSelected(){
    if(!state.selectedObject){ showHUDMessage('No building selected', 900); return; }
    if(state.selectedObject.type === 'tower'){
      const t = state.selectedObject.obj;
      const base = { fire:{w:30,s:15}, cold:{w:25,s:20}, poison:{w:40,s:25} }[t.kind] || {w:20,s:20};
      const refundW = Math.floor(base.w * 0.5 * t.level);
      const refundS = Math.floor(base.s * 0.5 * t.level);
      state.wood += refundW; state.stone += refundS;
      const idx = state.towers.indexOf(t); if(idx>=0) state.towers.splice(idx,1);
      savePersist(state); updateHUD(); state.selectedObject = null; showHUDMessage(`Sold tower +${refundW}🪵 +${refundS}🪨`,1200); actionPanel.style.display='none'; return;
    }
    if(state.selectedObject.type === 'mine'){
      state.wood += Math.floor(COSTS.mine.wood * 0.5); state.stone += Math.floor(COSTS.mine.stone * 0.5);
      const m = state.selectedObject.obj; const idx = state.mines.indexOf(m); if(idx>=0) state.mines.splice(idx,1);
      savePersist(state); updateHUD(); state.selectedObject = null; showHUDMessage('Sold mine',1200); actionPanel.style.display='none'; return;
    }
    if(state.selectedObject.type === 'stash'){
      if(confirm('Destroying stash will wipe towers & mines (keeps your gold & resources). Proceed?')){ state.stash = null; state.towers=[]; state.mines=[]; savePersist(state); updateHUD(); state.selectedObject = null; showHUDMessage('Stash destroyed — base wiped',1300); actionPanel.style.display='none'; }
      return;
    }
  }

  function autoMouseHoldAction(dt){
    if(mouse.down){ if(state.handCooldown <= 0){ playerHandAction(); state.handCooldown = state.handMax; } }
  }

  // --- Update & draw ---
  function update(dt){
    updateDayNight(dt);
    if(state.handCooldown > 0) state.handCooldown = Math.max(0, state.handCooldown - dt);
    autoMouseHoldAction(dt);
    if(state.player) state.player.update(dt);
    for(const r of state.resourceNodes) r.update(dt);
    for(const t of state.towers) t.update(dt);
    for(const m of state.mines) m.update(dt);
    for(const m of state.mines){
      const amt = m.accum;
      if(amt >= 1){ state.gold += Math.floor(amt); m.accum = 0; savePersist(state); showHUDMessage(`+${Math.floor(amt)} gold (auto)`, 600); updateHUD(); }
    }
    for(const e of state.enemies) e.update(dt);
    updateBullets(dt);
    for(let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      if(e.hp <= 0){ state.gold += (e.type==='tank'?40: e.type==='runner'?12:10); state.enemies.splice(i,1); savePersist(state); showHUDMessage('+ gold', 700); }
    }
    if(state.stash && state.stash.hp <= 0){
      state.stash = null; state.towers = []; state.mines = []; state.player.x = MAP_W/2 + 48; state.player.y = MAP_H/2 + 8; savePersist(state); showHUDMessage('Stash destroyed — base wiped', 1800);
    }
    state.cam.x = clamp(state.player.x - canvas.width/2, 0, MAP_W - canvas.width);
    state.cam.y = clamp(state.player.y - canvas.height/2, 0, MAP_H - canvas.height);
    updateHUD();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = state.inNight ? '#05151a' : '#0b2630'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const offX = state.cam.x, offY = state.cam.y;
    ctx.save(); ctx.globalAlpha = 0.06; ctx.fillStyle = '#fff';
    const step = 40; for(let gx = - (offX % step); gx < canvas.width; gx += step) ctx.fillRect(gx, 0, 1, canvas.height);
    for(let gy = - (offY % step); gy < canvas.height; gy += step) ctx.fillRect(0, gy, canvas.width, 1);
    ctx.restore();
    const bx = MAP_W/2 - offX, by = MAP_H/2 - offY;
    ctx.save(); ctx.translate(bx, by); ctx.fillStyle = '#3b6'; roundRect(-40,-40,80,80,10,true); ctx.fillStyle='#072'; ctx.fillRect(-12,-12,24,24); ctx.restore();
    for(const r of state.resourceNodes) r.draw(offX, offY);
    for(const m of state.mines) m.draw(offX, offY);
    if(state.stash){ const sx = state.stash.x - offX, sy = state.stash.y - offY; ctx.save(); ctx.translate(sx, sy); ctx.fillStyle = '#ffd36b'; roundRect(-18,-14,36,28,6,true); ctx.fillStyle='#000'; ctx.font='12px monospace'; ctx.fillText('STASH', -16, 4); ctx.restore(); }
    for(const t of state.towers){
      t.draw(offX, offY, state.selectedObject && state.selectedObject.type==='tower' && state.selectedObject.obj === t);
      // draw range circle if tower is selected
      if(state.selectedObject && state.selectedObject.type === 'tower' && state.selectedObject.obj === t){
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.strokeStyle = '#ffd36b';
        ctx.lineWidth = 2;
        const sx = t.x - state.cam.x;
        const sy = t.y - state.cam.y;
        ctx.beginPath();
        ctx.arc(sx, sy, t.range || 160, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    if(state.player) state.player.draw(offX, offY);
    for(const e of state.enemies) e.draw(offX, offY);
    ctx.fillStyle = '#ffd';
    for(const b of state.bullets){ const bx = b.x - offX, by = b.y - offY; if(bx < -50 || bx > canvas.width+50 || by < -50 || by > canvas.height+50) continue; ctx.beginPath(); ctx.arc(bx,by,4,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fillRect(12, canvas.height - 46, 560, 36);
    ctx.fillStyle = '#fff'; ctx.font = '13px monospace';
    ctx.fillText('Enemies: ' + state.enemies.length + '  Towers: ' + state.towers.length + '  Mines: ' + state.mines.length, 18, canvas.height - 22);
    if(state.selectedBuild){
      const wx = state.cam.x + mouse.x, wy = state.cam.y + mouse.y;
      const snap = snapToGrid(wx,wy);
      const sx = snap.x - offX, sy = snap.y - offY;
      ctx.save(); ctx.globalAlpha = 0.95; ctx.fillStyle = '#fff'; roundRect(sx - 20, sy - 16, 40, 32, 6, true);
      ctx.fillStyle = '#000'; ctx.font = '12px monospace'; ctx.fillText(state.selectedBuild.toUpperCase(), sx - 18, sy + 4); ctx.restore();
    }
    if(state.inNight){ ctx.fillStyle = 'rgba(5,10,20,0.22)'; ctx.fillRect(0,0,canvas.width,canvas.height); }
  }

  function updateHUD(){
    HUD_gold.textContent = Math.floor(state.gold);
    HUD_wood.textContent = Math.floor(state.wood);
    HUD_stone.textContent = Math.floor(state.stone);
    HUD_hpText.textContent = `${Math.max(0,Math.round(state.player?state.player.hp:100))}/100`;
    HUD_hpFill.style.width = `${clamp((state.player?state.player.hp:100)/100, 0, 1)*100}%`;
    HUD_wave.textContent = state.wave;
    HUD_lives.textContent = state.lives;
  }

  // --- Init world ---
  function initWorld(){
    state.resourceNodes = [];
    const cx = MAP_W/2, cy = MAP_H/2;
    for(let i=0;i<48;i++){
      let a = Math.random()*Math.PI*2, r = 160 + Math.random()*520;
      const x = clamp(cx + Math.cos(a)*r, 60, MAP_W-60), y = clamp(cy + Math.sin(a)*r, 60, MAP_H-60);
      const type = Math.random() < 0.56 ? 'tree' : 'rock';
      state.resourceNodes.push(new ResourceNode(x,y,type));
    }
    state.towers = []; state.mines = []; state.enemies = []; state.bullets = []; state.stash = null;
    state.player = new Player(MAP_W/2 + 48, MAP_H/2 + 8);
    state.wave = 0; state.lives = 10;
    loadPersist(state); updateHUD(); state.timeOfDay = 8; state._nightStarted = false;
    showHUDMessage('World ready. Build a Gold Stash first (🏆).', 2500);
  }

  // --- UI wiring (safe order) ---
  bindBuildButtons((kind) => { state.selectedBuild = kind; state.selectedTool = 'hand'; showHUDMessage('Selected: ' + kind, 1200); });

  if(forceBtn) forceBtn.addEventListener('click', () => { state.timeOfDay = state.cycleDay + 0.01; showHUDMessage('Forced night'); });
  if(wipeBtn) wipeBtn.addEventListener('click', () => { if(confirm('Wipe towers & mines?')){ state.towers=[]; state.mines=[]; state.stash=null; savePersist(state); showHUDMessage('Base wiped'); updateHUD(); }});
  if(sellBtn) sellBtn.addEventListener('click', () => { sellSelected(); updateHUD(); });

  if(toolHandBtn) toolHandBtn.addEventListener('click', () => { state.selectedTool = 'hand'; state.selectedBuild = null; actionPanel.style.display='none'; showHUDMessage('Tool: Hand',900); });
  if(toolAxeBtn)  toolAxeBtn.addEventListener('click',  () => { state.selectedTool = 'axe';  state.selectedBuild = null; actionPanel.style.display='none'; showHUDMessage('Tool: Axe',900); });

  actionSellBtn.addEventListener('click', () => { sellSelected(); updateHUD(); });
  actionCloseBtn.addEventListener('click', () => { actionPanel.style.display='none'; });
  if(actionUpgradeBtn) actionUpgradeBtn.addEventListener('click', () => { upgradeSelected(); });

  canvas.addEventListener('dblclick', () => { const wx = state.cam.x + mouse.x, wy = state.cam.y + mouse.y; placeSelectedBuild(wx,wy); });
  canvas.addEventListener('click', () => { const wx = state.cam.x + mouse.x, wy = state.cam.y + mouse.y; if(state.selectedBuild){ placeSelectedBuild(wx,wy); } else { pickAt(wx,wy); }});
  canvas.addEventListener('mousedown', (e) => { if(e.button===0) playerHandAction(); });

  document.addEventListener('keydown', (e) => {
    if(e.key === ' ') { playerHandAction(); e.preventDefault(); }
    if(e.key === '1') { state.selectedBuild = 'stash'; state.selectedTool='hand'; }
    if(e.key === '2') { state.selectedBuild = 'mine'; state.selectedTool='hand'; }
    if(e.key === '3') { state.selectedBuild = 'fire'; state.selectedTool='hand'; }
    if(e.key === '4') { state.selectedBuild = 'cold'; state.selectedTool='hand'; }
    if(e.key === '5') { state.selectedBuild = 'poison'; state.selectedTool='hand'; }
    if(e.key.toLowerCase() === 'e'){
      const wx = state.cam.x + mouse.x, wy = state.cam.y + mouse.y; let acted=false;
      for(const r of state.resourceNodes){ if(Math.hypot(r.x - wx, r.y - wy) < r.size + 12){ if(state.selectedTool==='axe'){ r.harvest(state); updateHUD(); acted=true; break; } else { showHUDMessage('Need Axe to harvest',900); acted=true; break; } } }
      if(!acted){ for(const m of state.mines){ if(Math.hypot(m.x - wx, m.y - wy) < m.size + 12){ const amt=Math.floor(m.accum); if(amt>0){ state.gold += amt; m.accum=0; savePersist(state); updateHUD(); showHUDMessage(`+${amt} gold`); acted=true; break; } } } }
      if(!acted) showHUDMessage('Nothing to harvest here', 900);
    }
    if(e.key.toLowerCase() === 'r'){ if(confirm('Reset world? Resources & gold will remain.')) initWorld(); }
  });

  // --- Main loop ---
  let last = performance.now();
  function loop(now){
    try {
      const dt = Math.min(0.06, (now - last)/1000); last = now;
      update(dt); draw(); updateHUDMessageTimer(dt);
    } catch(err){
      console.error('Runtime error:', err);
      ctx.save(); ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff'; ctx.font = '16px monospace'; ctx.fillText('Runtime error — check console', 10, 30);
      ctx.restore();
      return;
    }
    requestAnimationFrame(loop);
  }

  // --- Startup ---
  try {
    initWorld();
    spawnWave(0);
    requestAnimationFrame(loop);
    window._zstate = state;
    console.log('Game started. window._zstate available.');
  } catch(err){
    console.error('Init failed:', err);
    showHUDMessage('Init failed — check console', 6000);
  }

  window._dump = { state, canvas, ctx, savePersist, loadPersist, spawnWave, placeSelectedBuild, sellSelected };

})();
</script>
</body>
</html>
